{"version":3,"sources":["streamlit_copilot.tsx","index.tsx"],"names":["Copilot","StreamlitComponentBase","userTextarea","suggestionTextarea","state","requestsThisMinute","currentMinute","Math","floor","Date","now","totalRequests","successfulRequests","failedRequests","inputCost","outputCost","totalCost","debounceTimer","render","theme","this","props","height_int","args","font_fam","font","f_height","f_focused","primaryColor","f_not_focused","secondaryBackgroundColor","style","fontSize","color","textColor","marginBottom","padding","backgroundColor","borderRadius","border","display","justifyContent","alignItems","toFixed","onClick","resetCounters","cursor","title","tabIndex","height","width","isFocused","overflowY","overflowX","position","onFocus","_onFocus","onBlur","_onBlur","marginLeft","fontFamily","marginTop","whiteSpace","outline","base","value","suggestion","readOnly","ref","textarea","text","onChange","onKeyDown","_onTextAreaBlur","onScroll","forceUpdate","event","target","setState","window","clearTimeout","timer","setTimeout","trim","api_upl","callApi","then","key","preventDefault","prevState","syntheticEvent","textAreaIsFocused","Streamlit","setComponentValue","abortController","AbortController","async","abort","Promise","resolve","prompt_template","api_url","api_key","questionText","question_title","model_kwargs","prompt","replace","isChatApi","includes","payload","validParams","model","max_tokens","temperature","top_p","stop","messages","role","content","stream","echo","headers","response","fetch","method","body","JSON","stringify","signal","ok","errorText","console","error","Error","status","responseJson","json","inputTokens","usage","prompt_tokens","outputTokens","completion_tokens","inputPrice","outputPrice","estimatedInputTokens","ceil","length","newInputCost","newOutputCost","fullResponse","choices","message","log","extractedAnswer","answerTagIndex","indexOf","substring","endTagIndex","name","componentDidUpdate","scrollTop","componentWillUnmount","withStreamlitConnection","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4a5420b7.chunk.js","sourcesContent":["import {\n  StreamlitComponentBase,\n  withStreamlitConnection,\n  Streamlit,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\n\ninterface State {\n  text: string\n  suggestion: string\n  isFocused: boolean\n  textAreaIsFocused: boolean\n  requestsThisMinute: number\n  currentMinute: number\n  totalRequests: number\n  successfulRequests: number\n  failedRequests: number\n  inputCost: number\n  outputCost: number\n  totalCost: number\n  debounceTimer: number | null\n}\n\nclass Copilot extends StreamlitComponentBase<State> {\n\n  private userTextarea: HTMLTextAreaElement | null = null;\n  private suggestionTextarea: HTMLTextAreaElement | null = null;\n  public state = {\n    \"text\": \"\",\n    \"suggestion\": \"\",\n    \"isFocused\": false,\n    'textAreaIsFocused': false,\n    requestsThisMinute: 0,\n    currentMinute: Math.floor(Date.now() / 60000),\n    totalRequests: 0,\n    successfulRequests: 0,\n    failedRequests: 0,\n    inputCost: 0,\n    outputCost: 0,\n    totalCost: 0,\n    debounceTimer: null\n  }\n\n  public render = (): ReactNode => {\n    const { theme } = this.props\n    if (!theme) {\n      return <div>Theme is undefined, please check streamlit version.</div>\n    }\n    const height_int = this.props.args[\"height\"]\n    const font_fam = theme.font;\n\n    const f_height = height_int + 'px';\n\n    const f_focused = '1px solid ' + theme.primaryColor;\n    const f_not_focused = '1px solid ' + theme.secondaryBackgroundColor;\n\n    return (\n        <div>\n          {/* Request Counter Display */}\n          <div style={{\n            fontSize: '1em',\n            color: theme.textColor,\n            marginBottom: '0.5em',\n            padding: '0.5em',\n            backgroundColor: theme.backgroundColor,\n            borderRadius: '0.3em',\n            border: '1px solid ' + theme.secondaryBackgroundColor,\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center'\n          }}>\n            <div>\n               <strong>API Stats:</strong> Total: {this.state.totalRequests} | \n              ✅ Success: {this.state.successfulRequests} | \n              ❌ Failed: {this.state.failedRequests} | \n              {/* Shows how many API requests have been made in the current minute, out of the allowed requests per minute (RPM) limit */}\n              Requests this per minute / limit: {this.state.requestsThisMinute} / {this.props.args[\"rpm_limit\"]} \n              <br />\n              <strong>Cost:</strong> Input: ${this.state.inputCost.toFixed(6)} | Output: ${this.state.outputCost.toFixed(6)} | Total: ${this.state.totalCost.toFixed(6)}\n              \n              \n            </div>\n            <button\n              onClick={this.resetCounters}\n              style={{\n                fontSize: '0.7em',\n                padding: '0.2em 0.5em',\n                backgroundColor: theme.primaryColor,\n                color: 'white',\n                border: 'none',\n                borderRadius: '0.3em',\n                cursor: 'pointer'\n              }}\n              title=\"Reset counters\"\n            >\n              🔄 Reset\n            </button>\n          </div>\n          \n          <div\n            tabIndex={0}\n            style={\n              {\n                height:f_height,\n                width:'auto',\n                border:this.state.isFocused ? f_focused: f_not_focused,\n                borderRadius:'0.5em',\n                overflowY:'scroll',\n                overflowX:'hidden',\n                position: 'relative',\n                backgroundColor: theme.secondaryBackgroundColor\n              }\n            }\n            onFocus={this._onFocus}\n            onBlur={this._onBlur}\n          >\n            <textarea\n              style={\n                {\n                  marginLeft:'0.5em',\n                  fontFamily:font_fam,\n                  marginTop:'0.2em',\n                  whiteSpace: 'pre-wrap',\n                  width:  'calc(100% - 1.2em)',\n                  height: '100%',\n                  border: 'none',\n                  outline: 'none',\n                  position: 'absolute',\n                  backgroundColor: 'transparent',\n                  color: theme.base === 'light' ? 'rgba(41,51,62,0.5)' : 'rgba(255,255,255,0.5)',\n                  padding: '0'\n                }\n              }\n              value={this.state.suggestion}\n              readOnly\n              ref={(textarea) => { this.suggestionTextarea = textarea; }}\n            />\n            <textarea\n              style={\n              {\n                marginLeft:'0.5em',\n                fontFamily:font_fam,\n                marginTop:'0.2em',\n                whiteSpace: 'pre-wrap',\n                width:  'calc(100% - 1.2em)',\n                height: '100%',\n                border: 'none',\n                outline: 'none',\n                position: 'absolute',\n                backgroundColor: 'transparent',\n                color:theme.textColor,\n                padding: '0'\n              }\n            }\n              value={this.state.text}\n              onChange={this.onChange}\n              onKeyDown={this.onKeyDown}\n              onBlur={this._onTextAreaBlur}\n              onScroll={this.onScroll}\n              ref={(textarea) => { this.userTextarea = textarea; }}\n            />\n          </div>\n        </div>\n    )\n  }\n\n  public componentDidUpdate(): void {\n  if (this.userTextarea && this.suggestionTextarea) {\n    this.suggestionTextarea.scrollTop = this.userTextarea.scrollTop;\n  }\n}\nprivate onScroll = (): void => {\n    this.forceUpdate();\n  }\n  private onChange = (event: React.ChangeEvent<HTMLTextAreaElement>): void => {\n    const text = event.target.value\n    this.setState({ text, suggestion: \"\" })\n    \n    // Clear any existing timer\n    if (this.state.debounceTimer !== null) {\n      window.clearTimeout(this.state.debounceTimer!)\n    }\n    \n    // Set a new debounced timer (500ms delay)\n    const timer = window.setTimeout(() => {\n      if (text.trim() !== \"\") {\n        const api_upl = this.props.args[\"api_url\"]\n        this.callApi(text, api_upl).then(suggestion => {\n          if (this.state.text.trim() !== \"\") {\n            this.setState({ suggestion: this.state.text + suggestion })\n          }\n        })\n      }\n    }, 500) // Wait 500ms after user stops typing\n    \n    this.setState({ debounceTimer: timer })\n  }\n\n\n  private onKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>): void => {\n  if (event.key === 'Tab') {\n    event.preventDefault()\n    this.setState(prevState => ({\n      text: prevState.suggestion,\n      suggestion: ''\n    }), () => {\n      // Create a synthetic event and call onChange manually\n      const syntheticEvent = {\n        target: { value: this.state.text }\n      } as React.ChangeEvent<HTMLTextAreaElement>;\n      this.onChange(syntheticEvent);\n    })\n  }\n}\n\n  private _onTextAreaBlur = (): void => {\n    this.setState({ textAreaIsFocused: false }, () => {\n      Streamlit.setComponentValue(this.state.text);\n      this.setState({ suggestion: '' });\n    });\n  }\n\n  private _onFocus = (): void => {\n    this.setState({ isFocused: true })\n  }\n\n  private _onBlur = (): void => {\n    this.setState({ isFocused: false })\n  }\n\n  private resetCounters = (): void => {\n    this.setState({\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      requestsThisMinute: 0,\n      inputCost: 0,\n      outputCost: 0,\n      totalCost: 0\n    });\n  }\n\n  // Cleanup timer when component unmounts\n  componentWillUnmount(): void {\n    if (this.state.debounceTimer !== null) {\n      window.clearTimeout(this.state.debounceTimer!)\n    }\n  }\n\n  private abortController = new AbortController();\n\nprivate callApi = async (text: string, api_upl: string): Promise<string> => {\n  // Abort the previous request\n  this.abortController.abort();\n  this.abortController = new AbortController();\n\n  if (text.trim() === \"\") {\n    return \"\";\n  }\n\n  const currentMinute = Math.floor(Date.now() / 60000);\n  if (currentMinute > this.state.currentMinute) {\n    this.setState({\n      currentMinute: currentMinute,\n      requestsThisMinute: 0\n    });\n  } else if (this.state.requestsThisMinute > this.props.args[\"rpm_limit\"]) {\n    // Retry after 1 second if limit is exceeded\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(this.callApi(text, api_upl));\n      }, 1000);\n    });\n  }\n\n  const {prompt_template, api_url, api_key, height, fontFamily, border, text: questionText, question_title, ...model_kwargs} = this.props.args;\n  const prompt = prompt_template\n    .replace(\"{text}\", questionText || \"\")\n    .replace(\"{question_title}\", question_title || \"\"); // format the prompt with both placeholders\n  \n  // Generalize to support both chat and legacy completions APIs, not just Groq\n  // Determine if the API expects chat format (messages) or legacy format (prompt)\n  // Use a prop or model_kwargs to allow user to specify the format, fallback to auto-detect\n  const isChatApi = (\n    this.props.args[\"api_format\"] === \"chat\" ||\n    api_upl.includes('/chat/completions')\n  );\n\n  let payload;\n  if (isChatApi) {\n    // Use chat completions format for any compatible API\n    const validParams: any = {};\n    if (model_kwargs.model) validParams.model = model_kwargs.model;\n    if (model_kwargs.max_tokens) validParams.max_tokens = model_kwargs.max_tokens;\n    if (model_kwargs.temperature) validParams.temperature = model_kwargs.temperature;\n    if (model_kwargs.top_p) validParams.top_p = model_kwargs.top_p;\n    if (model_kwargs.stop) validParams.stop = model_kwargs.stop;\n\n    payload = {\n      messages: [\n        {\n          role: \"user\",\n          content: prompt\n        }\n      ],\n      ...validParams,\n      stream: false\n    };\n  } else {\n    // Use legacy completions format for other APIs\n    payload = {\n      prompt: prompt,\n      ...model_kwargs,\n      echo: false\n    };\n  }\n  \n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json'\n  };\n  \n  // Add API key if provided\n  if (api_key) {\n    headers['Authorization'] = `Bearer ${api_key}`;\n  }\n\n  try {\n    // Increment total requests counter\n    this.setState(prevState => ({\n      totalRequests: prevState.totalRequests + 1\n    }));\n    \n    const response = await fetch(api_upl, {\n      method: \"POST\",\n      headers: headers,\n      body: JSON.stringify(payload),\n      signal: this.abortController.signal\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(\"API Error Response:\", errorText);\n      \n      // Increment failed requests counter\n      this.setState(prevState => ({\n        failedRequests: prevState.failedRequests + 1\n      }));\n      \n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    this.setState(prevState => ({\n      requestsThisMinute: prevState.requestsThisMinute + 1,\n      successfulRequests: prevState.successfulRequests + 1\n    }));\n\n    const responseJson = await response.json();\n    \n    // Calculate costs based on token usage\n    const inputTokens = responseJson.usage?.prompt_tokens || 0;\n    const outputTokens = responseJson.usage?.completion_tokens || 0;\n    \n    const inputPrice = this.props.args[\"token_cost\"] || 0.05;\n    const outputPrice = this.props.args[\"output_token_cost\"] || 0.10;\n    \n    // If no usage info, estimate based on text length (rough approximation)\n    const estimatedInputTokens = inputTokens || Math.ceil(prompt.length / 4);\n    const estimatedOutputTokens = outputTokens || 0;\n    \n    const newInputCost = (estimatedInputTokens / 1_000_000) * inputPrice;\n    const newOutputCost = (estimatedOutputTokens / 1_000_000) * outputPrice;\n    \n    this.setState(prevState => ({\n      inputCost: prevState.inputCost + newInputCost,\n      outputCost: prevState.outputCost + newOutputCost,\n      totalCost: prevState.totalCost + newInputCost + newOutputCost\n    }));\n    \n    // Handle both chat completions and legacy completions formats\n    let fullResponse = \"\";\n    if (isChatApi && responseJson.choices && responseJson.choices[0] && responseJson.choices[0].message) {\n      fullResponse = responseJson.choices[0].message.content;\n    } else if (responseJson.choices && responseJson.choices[0] && responseJson.choices[0].text) {\n      fullResponse = responseJson.choices[0].text;\n    } else {\n      console.error(\"Unexpected response format:\", responseJson);\n      return \"\";\n    }\n    \n    // Log the full response to console (this will show the thinking process)\n    console.log(\"Full AI Response:\", fullResponse);\n    \n    // Extract only the content after <answer> tag\n    let extractedAnswer = \"\";\n    const answerTagIndex = fullResponse.indexOf(\"<answer>\");\n    if (answerTagIndex !== -1) {\n      extractedAnswer = fullResponse.substring(answerTagIndex + 8); // 8 is the length of \"<answer>\"\n      // Remove any trailing tags or extra content\n      const endTagIndex = extractedAnswer.indexOf(\"</answer>\");\n      if (endTagIndex !== -1) {\n        extractedAnswer = extractedAnswer.substring(0, endTagIndex);\n      }\n    } else {\n      // If no <answer> tag found, return the full response\n      extractedAnswer = fullResponse;\n    }\n    \n    // Log the extracted answer for debugging\n    console.log(\"Extracted Answer:\", extractedAnswer);\n    \n    return extractedAnswer;\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      return \"\";  // Return empty string if request was aborted\n    }\n    console.error(\"Error decoding response\", error);\n    return \"\";\n  }\n}\n}\n\nexport default withStreamlitConnection(Copilot)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport ScrollableText from \"./streamlit_copilot\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <ScrollableText />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}