{"version":3,"sources":["streamlit_copilot.tsx","index.tsx"],"names":["Copilot","StreamlitComponentBase","userTextarea","suggestionTextarea","state","requestsThisMinute","currentMinute","Math","floor","Date","now","totalRequests","successfulRequests","failedRequests","inputCost","outputCost","totalCost","debounceTimer","render","theme","this","props","height_int","args","font_fam","font","f_height","f_focused","primaryColor","f_not_focused","secondaryBackgroundColor","style","fontSize","color","textColor","marginBottom","padding","backgroundColor","borderRadius","border","display","justifyContent","alignItems","toFixed","onClick","resetCounters","cursor","title","tabIndex","height","width","isFocused","overflowY","overflowX","position","onFocus","_onFocus","onBlur","_onBlur","marginLeft","fontFamily","marginTop","whiteSpace","outline","base","value","suggestion","readOnly","ref","textarea","text","onChange","onKeyDown","_onTextAreaBlur","onScroll","forceUpdate","event","target","setState","window","clearTimeout","timer","setTimeout","trim","api_upl","callApi","then","key","preventDefault","prevState","syntheticEvent","textAreaIsFocused","Streamlit","setComponentValue","abortController","AbortController","executeToolCalls","async","results","toolCall","toolCalls","functionName","function","name","JSON","parse","arguments","console","log","mockResult","getMockToolResult","push","toolName","query","toString","String","queryLower","toLowerCase","includes","makeFollowUpCall","apiUrl","userInput","toolResults","followUpPrompt","join","prompt_template","api_key","questionText","question_title","model_kwargs","isChatApi","replace","payload","validParams","model","max_tokens","temperature","top_p","stop","messages","role","content","stream","prompt","echo","headers","response","fetch","method","body","stringify","signal","ok","Error","status","responseJson","json","fullResponse","choices","message","error","extractedAnswer","answerTagIndex","indexOf","substring","endTagIndex","abort","Promise","resolve","api_url","tools","type","description","parameters","properties","required","tool_choice","errorText","inputTokens","usage","prompt_tokens","outputTokens","completion_tokens","inputPrice","outputPrice","estimatedInputTokens","ceil","length","newInputCost","newOutputCost","tool_calls","componentDidUpdate","scrollTop","componentWillUnmount","withStreamlitConnection","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.35abb179.chunk.js","sourcesContent":["import {\n  StreamlitComponentBase,\n  withStreamlitConnection,\n  Streamlit,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\n\ninterface State {\n  text: string\n  suggestion: string\n  isFocused: boolean\n  textAreaIsFocused: boolean\n  requestsThisMinute: number\n  currentMinute: number\n  totalRequests: number\n  successfulRequests: number\n  failedRequests: number\n  inputCost: number\n  outputCost: number\n  totalCost: number\n  debounceTimer: number | null\n}\n\nclass Copilot extends StreamlitComponentBase<State> {\n\n  private userTextarea: HTMLTextAreaElement | null = null;\n  private suggestionTextarea: HTMLTextAreaElement | null = null;\n  public state = {\n    \"text\": \"\",\n    \"suggestion\": \"\",\n    \"isFocused\": false,\n    'textAreaIsFocused': false,\n    requestsThisMinute: 0,\n    currentMinute: Math.floor(Date.now() / 60000),\n    totalRequests: 0,\n    successfulRequests: 0,\n    failedRequests: 0,\n    inputCost: 0,\n    outputCost: 0,\n    totalCost: 0,\n    debounceTimer: null\n  }\n\n  public render = (): ReactNode => {\n    const { theme } = this.props\n    if (!theme) {\n      return <div>Theme is undefined, please check streamlit version.</div>\n    }\n    const height_int = this.props.args[\"height\"]\n    const font_fam = theme.font;\n\n    const f_height = height_int + 'px';\n\n    const f_focused = '1px solid ' + theme.primaryColor;\n    const f_not_focused = '1px solid ' + theme.secondaryBackgroundColor;\n\n    return (\n        <div>\n          {/* Request Counter Display */}\n          <div style={{\n            fontSize: '1em',\n            color: theme.textColor,\n            marginBottom: '0.5em',\n            padding: '0.5em',\n            backgroundColor: theme.backgroundColor,\n            borderRadius: '0.3em',\n            border: '1px solid ' + theme.secondaryBackgroundColor,\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center'\n          }}>\n            <div>\n               <strong>API Stats:</strong> Total: {this.state.totalRequests} | \n              ✅ Success: {this.state.successfulRequests} | \n              ❌ Failed: {this.state.failedRequests} | \n              {/* Shows how many API requests have been made in the current minute, out of the allowed requests per minute (RPM) limit */}\n              Requests this per minute / limit: {this.state.requestsThisMinute} / {this.props.args[\"rpm_limit\"]} \n              <br />\n              <strong>Cost:</strong> Input: ${this.state.inputCost.toFixed(6)} | Output: ${this.state.outputCost.toFixed(6)} | Total: ${this.state.totalCost.toFixed(6)}\n              \n              \n            </div>\n            <button\n              onClick={this.resetCounters}\n              style={{\n                fontSize: '0.7em',\n                padding: '0.2em 0.5em',\n                backgroundColor: theme.primaryColor,\n                color: 'white',\n                border: 'none',\n                borderRadius: '0.3em',\n                cursor: 'pointer'\n              }}\n              title=\"Reset counters\"\n            >\n              🔄 Reset\n            </button>\n          </div>\n          \n          <div\n            tabIndex={0}\n            style={\n              {\n                height:f_height,\n                width:'auto',\n                border:this.state.isFocused ? f_focused: f_not_focused,\n                borderRadius:'0.5em',\n                overflowY:'scroll',\n                overflowX:'hidden',\n                position: 'relative',\n                backgroundColor: theme.secondaryBackgroundColor\n              }\n            }\n            onFocus={this._onFocus}\n            onBlur={this._onBlur}\n          >\n            <textarea\n              style={\n                {\n                  marginLeft:'0.5em',\n                  fontFamily:font_fam,\n                  marginTop:'0.2em',\n                  whiteSpace: 'pre-wrap',\n                  width:  'calc(100% - 1.2em)',\n                  height: '100%',\n                  border: 'none',\n                  outline: 'none',\n                  position: 'absolute',\n                  backgroundColor: 'transparent',\n                  color: theme.base === 'light' ? 'rgba(41,51,62,0.5)' : 'rgba(255,255,255,0.5)',\n                  padding: '0'\n                }\n              }\n              value={this.state.suggestion}\n              readOnly\n              ref={(textarea) => { this.suggestionTextarea = textarea; }}\n            />\n            <textarea\n              style={\n              {\n                marginLeft:'0.5em',\n                fontFamily:font_fam,\n                marginTop:'0.2em',\n                whiteSpace: 'pre-wrap',\n                width:  'calc(100% - 1.2em)',\n                height: '100%',\n                border: 'none',\n                outline: 'none',\n                position: 'absolute',\n                backgroundColor: 'transparent',\n                color:theme.textColor,\n                padding: '0'\n              }\n            }\n              value={this.state.text}\n              onChange={this.onChange}\n              onKeyDown={this.onKeyDown}\n              onBlur={this._onTextAreaBlur}\n              onScroll={this.onScroll}\n              ref={(textarea) => { this.userTextarea = textarea; }}\n            />\n          </div>\n        </div>\n    )\n  }\n\n  public componentDidUpdate(): void {\n  if (this.userTextarea && this.suggestionTextarea) {\n    this.suggestionTextarea.scrollTop = this.userTextarea.scrollTop;\n  }\n}\nprivate onScroll = (): void => {\n    this.forceUpdate();\n  }\n  private onChange = (event: React.ChangeEvent<HTMLTextAreaElement>): void => {\n    const text = event.target.value\n    this.setState({ text, suggestion: \"\" })\n    \n    // Clear any existing timer\n    if (this.state.debounceTimer !== null) {\n      window.clearTimeout(this.state.debounceTimer!)\n    }\n    \n    // Set a new debounced timer (500ms delay)\n    const timer = window.setTimeout(() => {\n      if (text.trim() !== \"\") {\n        const api_upl = this.props.args[\"api_url\"]\n        this.callApi(text, api_upl).then(suggestion => {\n          if (this.state.text.trim() !== \"\") {\n            this.setState({ suggestion: this.state.text + suggestion })\n          }\n        })\n      }\n    }, 500) // Wait 500ms after user stops typing\n    \n    this.setState({ debounceTimer: timer })\n  }\n\n\n  private onKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>): void => {\n  if (event.key === 'Tab') {\n    event.preventDefault()\n    this.setState(prevState => ({\n      text: prevState.suggestion,\n      suggestion: ''\n    }), () => {\n      // Create a synthetic event and call onChange manually\n      const syntheticEvent = {\n        target: { value: this.state.text }\n      } as React.ChangeEvent<HTMLTextAreaElement>;\n      this.onChange(syntheticEvent);\n    })\n  }\n}\n\n  private _onTextAreaBlur = (): void => {\n    this.setState({ textAreaIsFocused: false }, () => {\n      Streamlit.setComponentValue(this.state.text);\n      this.setState({ suggestion: '' });\n    });\n  }\n\n  private _onFocus = (): void => {\n    this.setState({ isFocused: true })\n  }\n\n  private _onBlur = (): void => {\n    this.setState({ isFocused: false })\n  }\n\n  private resetCounters = (): void => {\n    this.setState({\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      requestsThisMinute: 0,\n      inputCost: 0,\n      outputCost: 0,\n      totalCost: 0\n    });\n  }\n\n  // Cleanup timer when component unmounts\n  componentWillUnmount(): void {\n    if (this.state.debounceTimer !== null) {\n      window.clearTimeout(this.state.debounceTimer!)\n    }\n  }\n\n  private abortController = new AbortController();\n\n  // Add tool call execution method\n  private executeToolCalls = async (toolCalls: any[]): Promise<string[]> => {\n    const results: string[] = [];\n    \n    for (const toolCall of toolCalls) {\n      const functionName = toolCall.function?.name;\n      const args = JSON.parse(toolCall.function?.arguments || '{}');\n      \n      console.log(`Executing tool: ${functionName} with args:`, args);\n      \n      if (functionName === 'search_knowledge_base') {\n        // For now, return a mock result since we can't get real-time response\n        // In a real implementation, you'd need to handle the response asynchronously\n        const mockResult = this.getMockToolResult(functionName, args);\n        results.push(mockResult);\n      } else {\n        results.push(`Unknown tool: ${functionName}`);\n      }\n    }\n    \n    return results;\n  }\n\n  // Mock tool results for demonstration\n  private getMockToolResult = (toolName: string, args: any): string => {\n    if (toolName === 'search_knowledge_base') {\n      // Extract query string safely\n      let query = '';\n      if (typeof args.query === 'string') {\n        query = args.query;\n      } else if (args.query && typeof args.query === 'object') {\n        // If query is an object, try to get the value\n        query = args.query.toString() || '';\n      } else {\n        query = String(args.query || '');\n      }\n      \n      const queryLower = query.toLowerCase();\n      console.log(`Processing query: \"${query}\" (lowercase: \"${queryLower}\")`);\n      \n      // Simple keyword matching (same as Python backend)\n      if (queryLower.includes('avgifter') || queryLower.includes('fees') || queryLower.includes('kostnad')) {\n        return \"Lysa charges 0.4% annually for investment accounts\";\n      } else if (queryLower.includes('sparkonto') || queryLower.includes('interest') || queryLower.includes('ränta')) {\n        return \"Sparkonto Auto offers 3.5% interest rate\";\n      } else if (queryLower.includes('pension')) {\n        return \"You can transfer your pension to Lysa with no fees\";\n      } else if (queryLower.includes('isk') || queryLower.includes('investment')) {\n        return \"ISK accounts have 0.4% annual fee and tax-efficient structure\";\n      } else if (queryLower.includes('contact') || queryLower.includes('support') || queryLower.includes('help')) {\n        return \"You can contact Lysa support via email at support@lysa.se or call +46 8 123 45 67\";\n      } else {\n        return `Searching for: \"${query}\". Found general information about Lysa services.`;\n      }\n    }\n    \n    return `Mock result for ${toolName}`;\n  }\n\n  // Add follow-up call method for tool results\n  private makeFollowUpCall = async (apiUrl: string, userInput: string, toolResults: string[]): Promise<string> => {\n    const followUpPrompt = `Based on search results: ${toolResults.join('\\n')}\\n\\nComplete: \"${userInput}\"`;\n    \n    const {prompt_template, api_key, height, fontFamily, border, text: questionText, question_title, ...model_kwargs} = this.props.args;\n    const prompt = prompt_template\n      .replace(\"{text}\", questionText || \"\")\n      .replace(\"{question_title}\", question_title || \"\");\n    \n    const isChatApi = (\n      this.props.args[\"api_format\"] === \"chat\" ||\n      apiUrl.includes('/chat/completions')\n    );\n\n    let payload;\n    if (isChatApi) {\n      const validParams: any = {};\n      if (model_kwargs.model) validParams.model = model_kwargs.model;\n      if (model_kwargs.max_tokens) validParams.max_tokens = model_kwargs.max_tokens;\n      if (model_kwargs.temperature) validParams.temperature = model_kwargs.temperature;\n      if (model_kwargs.top_p) validParams.top_p = model_kwargs.top_p;\n      if (model_kwargs.stop) validParams.stop = model_kwargs.stop;\n\n      payload = {\n        messages: [\n          {\n            role: \"user\",\n            content: followUpPrompt\n          }\n        ],\n        ...validParams,\n        stream: false\n      };\n    } else {\n      payload = {\n        prompt: followUpPrompt,\n        ...model_kwargs,\n        echo: false\n      };\n    }\n    \n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json'\n    };\n    \n    if (api_key) {\n      headers['Authorization'] = `Bearer ${api_key}`;\n    }\n\n    try {\n      const response = await fetch(apiUrl, {\n        method: \"POST\",\n        headers: headers,\n        body: JSON.stringify(payload),\n        signal: this.abortController.signal\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const responseJson = await response.json();\n      \n      let fullResponse = \"\";\n      if (isChatApi && responseJson.choices && responseJson.choices[0] && responseJson.choices[0].message) {\n        fullResponse = responseJson.choices[0].message.content;\n      } else if (responseJson.choices && responseJson.choices[0] && responseJson.choices[0].text) {\n        fullResponse = responseJson.choices[0].text;\n      } else {\n        console.error(\"Unexpected response format:\", responseJson);\n        return \"\";\n      }\n      \n      // Extract answer from response\n      let extractedAnswer = \"\";\n      const answerTagIndex = fullResponse.indexOf(\"<answer>\");\n      if (answerTagIndex !== -1) {\n        extractedAnswer = fullResponse.substring(answerTagIndex + 8);\n        const endTagIndex = extractedAnswer.indexOf(\"</answer>\");\n        if (endTagIndex !== -1) {\n          extractedAnswer = extractedAnswer.substring(0, endTagIndex);\n        }\n      } else {\n        extractedAnswer = fullResponse;\n      }\n      \n      return extractedAnswer;\n    } catch (error) {\n      console.error(\"Follow-up call error:\", error);\n      return \"\";\n    }\n  }\n\nprivate callApi = async (text: string, api_upl: string): Promise<string> => {\n  // Abort the previous request\n  this.abortController.abort();\n  this.abortController = new AbortController();\n\n  if (text.trim() === \"\") {\n    return \"\";\n  }\n\n  const currentMinute = Math.floor(Date.now() / 60000);\n  if (currentMinute > this.state.currentMinute) {\n    this.setState({\n      currentMinute: currentMinute,\n      requestsThisMinute: 0\n    });\n  } else if (this.state.requestsThisMinute > this.props.args[\"rpm_limit\"]) {\n    // Retry after 1 second if limit is exceeded\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(this.callApi(text, api_upl));\n      }, 1000);\n    });\n  }\n\n  const {prompt_template, api_url, api_key, height, fontFamily, border, text: questionText, question_title, ...model_kwargs} = this.props.args;\n  const prompt = prompt_template\n    .replace(\"{text}\", questionText || \"\")\n    .replace(\"{question_title}\", question_title || \"\"); // format the prompt with both placeholders\n  \n  // Generalize to support both chat and legacy completions APIs, not just Groq\n  // Determine if the API expects chat format (messages) or legacy format (prompt)\n  // Use a prop or model_kwargs to allow user to specify the format, fallback to auto-detect\n  const isChatApi = (\n    this.props.args[\"api_format\"] === \"chat\" ||\n    api_upl.includes('/chat/completions')\n  );\n\n  // Define tools for the API call\n  const tools = [\n    {\n      type: \"function\",\n      function: {\n        name: \"search_knowledge_base\",\n        description: \"Search the Lysa knowledge base for customer support information\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            query: {\n              type: \"string\",\n              description: \"Search query to find relevant information\"\n            }\n          },\n          required: [\"query\"]\n        }\n      }\n    }\n  ];\n\n  let payload;\n  if (isChatApi) {\n    // Use chat completions format for any compatible API\n    const validParams: any = {};\n    if (model_kwargs.model) validParams.model = model_kwargs.model;\n    if (model_kwargs.max_tokens) validParams.max_tokens = model_kwargs.max_tokens;\n    if (model_kwargs.temperature) validParams.temperature = model_kwargs.temperature;\n    if (model_kwargs.top_p) validParams.top_p = model_kwargs.top_p;\n    if (model_kwargs.stop) validParams.stop = model_kwargs.stop;\n\n    payload = {\n      messages: [\n        {\n          role: \"user\",\n          content: prompt\n        }\n      ],\n      ...validParams,\n      tools: tools,\n      tool_choice: \"auto\",\n      stream: false\n    };\n  } else {\n    // Use legacy completions format for other APIs\n    payload = {\n      prompt: prompt,\n      ...model_kwargs,\n      echo: false\n    };\n  }\n  \n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json'\n  };\n  \n  // Add API key if provided\n  if (api_key) {\n    headers['Authorization'] = `Bearer ${api_key}`;\n  }\n\n  try {\n    // Increment total requests counter\n    this.setState(prevState => ({\n      totalRequests: prevState.totalRequests + 1\n    }));\n    \n    const response = await fetch(api_upl, {\n      method: \"POST\",\n      headers: headers,\n      body: JSON.stringify(payload),\n      signal: this.abortController.signal\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(\"API Error Response:\", errorText);\n      \n      // Increment failed requests counter\n      this.setState(prevState => ({\n        failedRequests: prevState.failedRequests + 1\n      }));\n      \n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    this.setState(prevState => ({\n      requestsThisMinute: prevState.requestsThisMinute + 1,\n      successfulRequests: prevState.successfulRequests + 1\n    }));\n\n    const responseJson = await response.json();\n    \n    // Calculate costs based on token usage\n    const inputTokens = responseJson.usage?.prompt_tokens || 0;\n    const outputTokens = responseJson.usage?.completion_tokens || 0;\n    \n    const inputPrice = this.props.args[\"token_cost\"] || 0.05;\n    const outputPrice = this.props.args[\"output_token_cost\"] || 0.10;\n    \n    // If no usage info, estimate based on text length (rough approximation)\n    const estimatedInputTokens = inputTokens || Math.ceil(prompt.length / 4);\n    const estimatedOutputTokens = outputTokens || 0;\n    \n    const newInputCost = (estimatedInputTokens / 1_000_000) * inputPrice;\n    const newOutputCost = (estimatedOutputTokens / 1_000_000) * outputPrice;\n    \n    this.setState(prevState => ({\n      inputCost: prevState.inputCost + newInputCost,\n      outputCost: prevState.outputCost + newOutputCost,\n      totalCost: prevState.totalCost + newInputCost + newOutputCost\n    }));\n    \n    // Handle both chat completions and legacy completions formats\n    let fullResponse = \"\";\n    let message = null;\n    \n    if (isChatApi && responseJson.choices && responseJson.choices[0] && responseJson.choices[0].message) {\n      message = responseJson.choices[0].message;\n      fullResponse = message.content || \"\";\n    } else if (responseJson.choices && responseJson.choices[0] && responseJson.choices[0].text) {\n      fullResponse = responseJson.choices[0].text;\n    } else {\n      console.error(\"Unexpected response format:\", responseJson);\n      return \"\";\n    }\n    \n    // Log the full response to console (this will show the thinking process)\n    console.log(\"Full AI Response:\", fullResponse);\n    \n    // Check if there are tool calls\n    if (isChatApi && message && message.tool_calls && message.tool_calls.length > 0) {\n      console.log(\"Tool calls detected:\", message.tool_calls);\n      \n      // Execute the tool calls\n      const toolResults = await this.executeToolCalls(message.tool_calls);\n      console.log(\"Tool execution results:\", toolResults);\n      \n      // Make a follow-up call with the tool results\n      const finalResponse = await this.makeFollowUpCall(api_upl, text, toolResults);\n      return finalResponse;\n    }\n    \n    // Extract only the content after <answer> tag\n    let extractedAnswer = \"\";\n    const answerTagIndex = fullResponse.indexOf(\"<answer>\");\n    if (answerTagIndex !== -1) {\n      extractedAnswer = fullResponse.substring(answerTagIndex + 8); // 8 is the length of \"<answer>\"\n      // Remove any trailing tags or extra content\n      const endTagIndex = extractedAnswer.indexOf(\"</answer>\");\n      if (endTagIndex !== -1) {\n        extractedAnswer = extractedAnswer.substring(0, endTagIndex);\n      }\n    } else {\n      // If no <answer> tag found, return the full response\n      extractedAnswer = fullResponse;\n    }\n    \n    // Log the extracted answer for debugging\n    console.log(\"Extracted Answer:\", extractedAnswer);\n    \n    return extractedAnswer;\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      return \"\";  // Return empty string if request was aborted\n    }\n    console.error(\"Error decoding response\", error);\n    return \"\";\n  }\n}\n}\n\nexport default withStreamlitConnection(Copilot)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport ScrollableText from \"./streamlit_copilot\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <ScrollableText />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}