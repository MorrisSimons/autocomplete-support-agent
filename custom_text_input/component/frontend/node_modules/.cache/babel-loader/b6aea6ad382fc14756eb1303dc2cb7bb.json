{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/morrissimons/Desktop/lysa-support-agent/custom_text_input/component/frontend/node_modules/@babel/runtime/helpers/objectSpread2\");\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toFile = toFile;\nconst uploads_1 = require(\"./uploads.js\");\nconst uploads_2 = require(\"./uploads.js\");\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isBlobLike = value => value != null && typeof value === 'object' && typeof value.size === 'number' && typeof value.type === 'string' && typeof value.text === 'function' && typeof value.slice === 'function' && typeof value.arrayBuffer === 'function';\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isFileLike = value => value != null && typeof value === 'object' && typeof value.name === 'string' && typeof value.lastModified === 'number' && isBlobLike(value);\nconst isResponseLike = value => value != null && typeof value === 'object' && typeof value.url === 'string' && typeof value.blob === 'function';\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nasync function toFile(value, name, options) {\n  var _options;\n  (0, uploads_2.checkFileSupport)();\n  // If it's a promise, resolve it.\n  value = await value;\n  // If we've been given a `File` we don't need to do anything\n  if (isFileLike(value)) {\n    if (value instanceof File) {\n      return value;\n    }\n    return (0, uploads_1.makeFile)([await value.arrayBuffer()], value.name);\n  }\n  if (isResponseLike(value)) {\n    const blob = await value.blob();\n    name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop());\n    return (0, uploads_1.makeFile)(await getBytes(blob), name, options);\n  }\n  const parts = await getBytes(value);\n  name || (name = (0, uploads_1.getName)(value));\n  if (!((_options = options) === null || _options === void 0 ? void 0 : _options.type)) {\n    const type = parts.find(part => typeof part === 'object' && 'type' in part && part.type);\n    if (typeof type === 'string') {\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        type\n      });\n    }\n  }\n  return (0, uploads_1.makeFile)(parts, name, options);\n}\nasync function getBytes(value) {\n  let parts = [];\n  if (typeof value === 'string' || ArrayBuffer.isView(value) ||\n  // includes Uint8Array, Buffer, etc.\n  value instanceof ArrayBuffer) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(value instanceof Blob ? value : await value.arrayBuffer());\n  } else if ((0, uploads_1.isAsyncIterable)(value) // includes Readable, ReadableStream, etc.\n  ) {\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(value), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const chunk = _step.value;\n        parts.push(...(await getBytes(chunk))); // TODO, consider validating?\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } else {\n    var _value$constructor;\n    const constructor = value === null || value === void 0 ? void 0 : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;\n    throw new Error(\"Unexpected data type: \".concat(typeof value).concat(constructor ? \"; constructor: \".concat(constructor) : '').concat(propsForError(value)));\n  }\n  return parts;\n}\nfunction propsForError(value) {\n  if (typeof value !== 'object' || value === null) return '';\n  const props = Object.getOwnPropertyNames(value);\n  return \"; props: [\".concat(props.map(p => \"\\\"\".concat(p, \"\\\"\")).join(', '), \"]\");\n}","map":{"version":3,"mappings":"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","names":["exports","isBlobLike","value","size","type","text","slice","arrayBuffer","isFileLike","name","lastModified","isResponseLike","url","blob","toFile","options","File","URL","pathname","split","pop","getBytes","parts","find","part","ArrayBuffer","isView","push","Blob","chunk","constructor","Error","propsForError","props","Object","getOwnPropertyNames","map","p","join"],"sourceRoot":"","sources":["../src/internal/to-file.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}