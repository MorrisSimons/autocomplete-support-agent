{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/morrissimons/Desktop/lysa-support-agent/custom_text_input/component/frontend/node_modules/@babel/runtime/helpers/objectSpread2\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.maybeParseResponse = maybeParseResponse;\nexports.parseResponse = parseResponse;\nexports.hasAutoParseableInput = hasAutoParseableInput;\nexports.makeParseableResponseTool = makeParseableResponseTool;\nexports.isAutoParsableTool = isAutoParsableTool;\nexports.shouldParseToolCall = shouldParseToolCall;\nexports.validateInputTools = validateInputTools;\nexports.addOutputText = addOutputText;\nconst error_1 = require(\"../error.js\");\nconst parser_1 = require(\"../lib/parser.js\");\nfunction maybeParseResponse(response, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return _objectSpread(_objectSpread({}, response), {}, {\n      output_parsed: null,\n      output: response.output.map(item => {\n        if (item.type === 'function_call') {\n          return _objectSpread(_objectSpread({}, item), {}, {\n            parsed_arguments: null\n          });\n        }\n        if (item.type === 'message') {\n          return _objectSpread(_objectSpread({}, item), {}, {\n            content: item.content.map(content => _objectSpread(_objectSpread({}, content), {}, {\n              parsed: null\n            }))\n          });\n        } else {\n          return item;\n        }\n      })\n    });\n  }\n  return parseResponse(response, params);\n}\nfunction parseResponse(response, params) {\n  const output = response.output.map(item => {\n    if (item.type === 'function_call') {\n      return _objectSpread(_objectSpread({}, item), {}, {\n        parsed_arguments: parseToolCall(params, item)\n      });\n    }\n    if (item.type === 'message') {\n      const content = item.content.map(content => {\n        if (content.type === 'output_text') {\n          return _objectSpread(_objectSpread({}, content), {}, {\n            parsed: parseTextFormat(params, content.text)\n          });\n        }\n        return content;\n      });\n      return _objectSpread(_objectSpread({}, item), {}, {\n        content\n      });\n    }\n    return item;\n  });\n  const parsed = Object.assign({}, response, {\n    output\n  });\n  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n    addOutputText(parsed);\n  }\n  Object.defineProperty(parsed, 'output_parsed', {\n    enumerable: true,\n    get() {\n      for (const output of parsed.output) {\n        if (output.type !== 'message') {\n          continue;\n        }\n        for (const content of output.content) {\n          if (content.type === 'output_text' && content.parsed !== null) {\n            return content.parsed;\n          }\n        }\n      }\n      return null;\n    }\n  });\n  return parsed;\n}\nfunction parseTextFormat(params, content) {\n  var _params$text, _params$text$format, _params$text2;\n  if (((_params$text = params.text) === null || _params$text === void 0 ? void 0 : (_params$text$format = _params$text.format) === null || _params$text$format === void 0 ? void 0 : _params$text$format.type) !== 'json_schema') {\n    return null;\n  }\n  if ('$parseRaw' in ((_params$text2 = params.text) === null || _params$text2 === void 0 ? void 0 : _params$text2.format)) {\n    var _params$text3;\n    const text_format = (_params$text3 = params.text) === null || _params$text3 === void 0 ? void 0 : _params$text3.format;\n    return text_format.$parseRaw(content);\n  }\n  return JSON.parse(content);\n}\nfunction hasAutoParseableInput(params) {\n  var _params$text4;\n  if ((0, parser_1.isAutoParsableResponseFormat)((_params$text4 = params.text) === null || _params$text4 === void 0 ? void 0 : _params$text4.format)) {\n    return true;\n  }\n  return false;\n}\nfunction makeParseableResponseTool(tool, _ref) {\n  let {\n    parser,\n    callback\n  } = _ref;\n  const obj = _objectSpread({}, tool);\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nfunction isAutoParsableTool(tool) {\n  return (tool === null || tool === void 0 ? void 0 : tool['$brand']) === 'auto-parseable-tool';\n}\nfunction getInputToolByName(input_tools, name) {\n  return input_tools.find(tool => tool.type === 'function' && tool.name === name);\n}\nfunction parseToolCall(params, toolCall) {\n  var _params$tools;\n  const inputTool = getInputToolByName((_params$tools = params.tools) !== null && _params$tools !== void 0 ? _params$tools : [], toolCall.name);\n  return _objectSpread(_objectSpread(_objectSpread({}, toolCall), toolCall), {}, {\n    parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : (inputTool === null || inputTool === void 0 ? void 0 : inputTool.strict) ? JSON.parse(toolCall.arguments) : null\n  });\n}\nfunction shouldParseToolCall(params, toolCall) {\n  var _params$tools2;\n  if (!params) {\n    return false;\n  }\n  const inputTool = getInputToolByName((_params$tools2 = params.tools) !== null && _params$tools2 !== void 0 ? _params$tools2 : [], toolCall.name);\n  return isAutoParsableTool(inputTool) || (inputTool === null || inputTool === void 0 ? void 0 : inputTool.strict) || false;\n}\nfunction validateInputTools(tools) {\n  for (const tool of tools !== null && tools !== void 0 ? tools : []) {\n    if (tool.type !== 'function') {\n      throw new error_1.OpenAIError(\"Currently only `function` tool types support auto-parsing; Received `\".concat(tool.type, \"`\"));\n    }\n    if (tool.function.strict !== true) {\n      throw new error_1.OpenAIError(\"The `\".concat(tool.function.name, \"` tool is not marked with `strict: true`. Only strict function tools can be auto-parsed\"));\n    }\n  }\n}\nfunction addOutputText(rsp) {\n  const texts = [];\n  for (const output of rsp.output) {\n    if (output.type !== 'message') {\n      continue;\n    }\n    for (const content of output.content) {\n      if (content.type === 'output_text') {\n        texts.push(content.text);\n      }\n    }\n  }\n  rsp.output_text = texts.join('');\n}","map":{"version":3,"mappings":"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","names":["exports","maybeParseResponse","response","params","hasAutoParseableInput","output_parsed","output","map","item","type","parsed_arguments","content","parsed","parseResponse","parseToolCall","parseTextFormat","text","Object","assign","getOwnPropertyDescriptor","addOutputText","defineProperty","enumerable","get","format","text_format","$parseRaw","JSON","parse","makeParseableResponseTool","tool","parser","callback","obj","defineProperties","$brand","value","$callback","isAutoParsableTool","getInputToolByName","input_tools","name","find","toolCall","inputTool","tools","arguments","strict","shouldParseToolCall","validateInputTools","error_1","function","rsp","texts","push","output_text","join"],"sourceRoot":"","sources":["../src/lib/ResponsesParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}