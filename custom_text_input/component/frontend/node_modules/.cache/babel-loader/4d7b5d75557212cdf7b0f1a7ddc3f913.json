{"ast":null,"code":"\"use strict\";\n\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _Webhooks_instances, _Webhooks_validateSecret, _Webhooks_getRequiredHeader;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Webhooks = void 0;\nconst tslib_1 = require(\"../internal/tslib.js\");\nconst error_1 = require(\"../error.js\");\nconst resource_1 = require(\"../core/resource.js\");\nconst headers_1 = require(\"../internal/headers.js\");\nclass Webhooks extends resource_1.APIResource {\n  constructor() {\n    super(...arguments);\n    _Webhooks_instances.add(this);\n  }\n  /**\n   * Validates that the given payload was sent by OpenAI and parses the payload.\n   */\n  async unwrap(payload, headers) {\n    let secret = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._client.webhookSecret;\n    let tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;\n    await this.verifySignature(payload, headers, secret, tolerance);\n    return JSON.parse(payload);\n  }\n  /**\n   * Validates whether or not the webhook payload was sent by OpenAI.\n   *\n   * An error will be raised if the webhook payload was not sent by OpenAI.\n   *\n   * @param payload - The webhook payload\n   * @param headers - The webhook headers\n   * @param secret - The webhook secret (optional, will use client secret if not provided)\n   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)\n   */\n  async verifySignature(payload, headers) {\n    let secret = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._client.webhookSecret;\n    let tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;\n    if (typeof crypto === 'undefined' || typeof crypto.subtle.importKey !== 'function' || typeof crypto.subtle.verify !== 'function') {\n      throw new Error('Webhook signature verification is only supported when the `crypto` global is defined');\n    }\n    tslib_1.__classPrivateFieldGet(this, _Webhooks_instances, \"m\", _Webhooks_validateSecret).call(this, secret);\n    const headersObj = (0, headers_1.buildHeaders)([headers]).values;\n    const signatureHeader = tslib_1.__classPrivateFieldGet(this, _Webhooks_instances, \"m\", _Webhooks_getRequiredHeader).call(this, headersObj, 'webhook-signature');\n    const timestamp = tslib_1.__classPrivateFieldGet(this, _Webhooks_instances, \"m\", _Webhooks_getRequiredHeader).call(this, headersObj, 'webhook-timestamp');\n    const webhookId = tslib_1.__classPrivateFieldGet(this, _Webhooks_instances, \"m\", _Webhooks_getRequiredHeader).call(this, headersObj, 'webhook-id');\n    // Validate timestamp to prevent replay attacks\n    const timestampSeconds = parseInt(timestamp, 10);\n    if (isNaN(timestampSeconds)) {\n      throw new error_1.InvalidWebhookSignatureError('Invalid webhook timestamp format');\n    }\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    if (nowSeconds - timestampSeconds > tolerance) {\n      throw new error_1.InvalidWebhookSignatureError('Webhook timestamp is too old');\n    }\n    if (timestampSeconds > nowSeconds + tolerance) {\n      throw new error_1.InvalidWebhookSignatureError('Webhook timestamp is too new');\n    }\n    // Extract signatures from v1,<base64> format\n    // The signature header can have multiple values, separated by spaces.\n    // Each value is in the format v1,<base64>. We should accept if any match.\n    const signatures = signatureHeader.split(' ').map(part => part.startsWith('v1,') ? part.substring(3) : part);\n    // Decode the secret if it starts with whsec_\n    const decodedSecret = secret.startsWith('whsec_') ? Buffer.from(secret.replace('whsec_', ''), 'base64') : Buffer.from(secret, 'utf-8');\n    // Create the signed payload: {webhook_id}.{timestamp}.{payload}\n    const signedPayload = webhookId ? \"\".concat(webhookId, \".\").concat(timestamp, \".\").concat(payload) : \"\".concat(timestamp, \".\").concat(payload);\n    // Import the secret as a cryptographic key for HMAC\n    const key = await crypto.subtle.importKey('raw', decodedSecret, {\n      name: 'HMAC',\n      hash: 'SHA-256'\n    }, false, ['verify']);\n    // Check if any signature matches using timing-safe WebCrypto verify\n    for (const signature of signatures) {\n      try {\n        const signatureBytes = Buffer.from(signature, 'base64');\n        const isValid = await crypto.subtle.verify('HMAC', key, signatureBytes, new TextEncoder().encode(signedPayload));\n        if (isValid) {\n          return; // Valid signature found\n        }\n      } catch (_unused) {\n        // Invalid base64 or signature format, continue to next signature\n        continue;\n      }\n    }\n    throw new error_1.InvalidWebhookSignatureError('The given webhook signature does not match the expected signature');\n  }\n}\nexports.Webhooks = Webhooks;\n_Webhooks_instances = new WeakSet(), _Webhooks_validateSecret = function _Webhooks_validateSecret(secret) {\n  if (typeof secret !== 'string' || secret.length === 0) {\n    throw new Error(\"The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function\");\n  }\n}, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader(headers, name) {\n  if (!headers) {\n    throw new Error(\"Headers are required\");\n  }\n  const value = headers.get(name);\n  if (value === null || value === undefined) {\n    throw new Error(\"Missing required header: \".concat(name));\n  }\n  return value;\n};","map":{"version":3,"mappings":";;AAAA;;;;;;;AAEA;AACA;AACA;AAEA,MAAaA,QAAS,SAAQC,sBAAW;EAAzCC;;;EAqIA;EApIE;;;EAGA,MAAMC,MAAM,CACVC,OAAe,EACfC,OAAoB,EAEG;IAAA,IADvBC,6EAAoC,IAAI,CAACC,OAAO,CAACC,aAAa;IAAA,IAC9DC,gFAAoB,GAAG;IAEvB,MAAM,IAAI,CAACC,eAAe,CAACN,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAEG,SAAS,CAAC;IAE/D,OAAOE,IAAI,CAACC,KAAK,CAACR,OAAO,CAAuB;EAClD;EAEA;;;;;;;;;;EAUA,MAAMM,eAAe,CACnBN,OAAe,EACfC,OAAoB,EAEG;IAAA,IADvBC,6EAAoC,IAAI,CAACC,OAAO,CAACC,aAAa;IAAA,IAC9DC,gFAAoB,GAAG;IAEvB,IACE,OAAOI,MAAM,KAAK,WAAW,IAC7B,OAAOA,MAAM,CAACC,MAAM,CAACC,SAAS,KAAK,UAAU,IAC7C,OAAOF,MAAM,CAACC,MAAM,CAACE,MAAM,KAAK,UAAU,EAC1C;MACA,MAAM,IAAIC,KAAK,CAAC,sFAAsF,CAAC;IACzG;IAEAC,mCAAI,qDAAgB,MAApB,IAAI,EAAiBZ,MAAM,CAAC;IAE5B,MAAMa,UAAU,GAAG,0BAAY,EAAC,CAACd,OAAO,CAAC,CAAC,CAACe,MAAM;IACjD,MAAMC,eAAe,GAAGH,mCAAI,wDAAmB,MAAvB,IAAI,EAAoBC,UAAU,EAAE,mBAAmB,CAAC;IAChF,MAAMG,SAAS,GAAGJ,mCAAI,wDAAmB,MAAvB,IAAI,EAAoBC,UAAU,EAAE,mBAAmB,CAAC;IAC1E,MAAMI,SAAS,GAAGL,mCAAI,wDAAmB,MAAvB,IAAI,EAAoBC,UAAU,EAAE,YAAY,CAAC;IAEnE;IACA,MAAMK,gBAAgB,GAAGC,QAAQ,CAACH,SAAS,EAAE,EAAE,CAAC;IAChD,IAAII,KAAK,CAACF,gBAAgB,CAAC,EAAE;MAC3B,MAAM,IAAIG,oCAA4B,CAAC,kCAAkC,CAAC;IAC5E;IAEA,MAAMC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,EAAE,GAAG,IAAI,CAAC;IAEhD,IAAIJ,UAAU,GAAGJ,gBAAgB,GAAGf,SAAS,EAAE;MAC7C,MAAM,IAAIkB,oCAA4B,CAAC,8BAA8B,CAAC;IACxE;IAEA,IAAIH,gBAAgB,GAAGI,UAAU,GAAGnB,SAAS,EAAE;MAC7C,MAAM,IAAIkB,oCAA4B,CAAC,8BAA8B,CAAC;IACxE;IAEA;IACA;IACA;IACA,MAAMM,UAAU,GAAGZ,eAAe,CAC/Ba,KAAK,CAAC,GAAG,CAAC,CACVC,GAAG,CAAEC,IAAI,IAAMA,IAAI,CAACC,UAAU,CAAC,KAAK,CAAC,GAAGD,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC,GAAGF,IAAK,CAAC;IAErE;IACA,MAAMG,aAAa,GACjBjC,MAAM,CAAC+B,UAAU,CAAC,QAAQ,CAAC,GACzBG,MAAM,CAACC,IAAI,CAACnC,MAAM,CAACoC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC,GACnDF,MAAM,CAACC,IAAI,CAACnC,MAAM,EAAE,OAAO,CAAC;IAEhC;IACA,MAAMqC,aAAa,GAAGpB,SAAS,aAAMA,SAAS,cAAID,SAAS,cAAIlB,OAAO,cAAQkB,SAAS,cAAIlB,OAAO,CAAE;IAEpG;IACA,MAAMwC,GAAG,GAAG,MAAM/B,MAAM,CAACC,MAAM,CAACC,SAAS,CACvC,KAAK,EACLwB,aAAa,EACb;MAAEM,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAE;IAAS,CAAE,EACjC,KAAK,EACL,CAAC,QAAQ,CAAC,CACX;IAED;IACA,KAAK,MAAMC,SAAS,IAAId,UAAU,EAAE;MAClC,IAAI;QACF,MAAMe,cAAc,GAAGR,MAAM,CAACC,IAAI,CAACM,SAAS,EAAE,QAAQ,CAAC;QACvD,MAAME,OAAO,GAAG,MAAMpC,MAAM,CAACC,MAAM,CAACE,MAAM,CACxC,MAAM,EACN4B,GAAG,EACHI,cAAc,EACd,IAAIE,WAAW,EAAE,CAACC,MAAM,CAACR,aAAa,CAAC,CACxC;QAED,IAAIM,OAAO,EAAE;UACX,OAAO,CAAC;QACV;MACF,CAAC,CAAC,gBAAM;QACN;QACA;MACF;IACF;IAEA,MAAM,IAAItB,oCAA4B,CACpC,mEAAmE,CACpE;EACH;;AA9GFyB;kGAgHkB9C,MAAiC;EAC/C,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAAC+C,MAAM,KAAK,CAAC,EAAE;IACrD,MAAM,IAAIpC,KAAK,qKAEd;EACH;AACF,CAAC,qEAEkBZ,OAAgB,EAAEwC,IAAY;EAC/C,IAAI,CAACxC,OAAO,EAAE;IACZ,MAAM,IAAIY,KAAK,wBAAwB;EACzC;EAEA,MAAMqC,KAAK,GAAGjD,OAAO,CAACkD,GAAG,CAACV,IAAI,CAAC;EAE/B,IAAIS,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKE,SAAS,EAAE;IACzC,MAAM,IAAIvC,KAAK,oCAA6B4B,IAAI,EAAG;EACrD;EAEA,OAAOS,KAAK;AACd,CAAC","names":["Webhooks","resource_1","constructor","unwrap","payload","headers","secret","_client","webhookSecret","tolerance","verifySignature","JSON","parse","crypto","subtle","importKey","verify","Error","tslib_1","headersObj","values","signatureHeader","timestamp","webhookId","timestampSeconds","parseInt","isNaN","error_1","nowSeconds","Math","floor","Date","now","signatures","split","map","part","startsWith","substring","decodedSecret","Buffer","from","replace","signedPayload","key","name","hash","signature","signatureBytes","isValid","TextEncoder","encode","exports","length","value","get","undefined"],"sourceRoot":"","sources":["../src/resources/webhooks.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}