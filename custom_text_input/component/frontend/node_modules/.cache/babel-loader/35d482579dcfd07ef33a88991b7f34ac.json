{"ast":null,"code":"\"use strict\";\n\nvar _awaitAsyncGenerator = require(\"/home/morrissimons/Desktop/lysa-support-agent/custom_text_input/component/frontend/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\nvar _wrapAsyncGenerator = require(\"/home/morrissimons/Desktop/lysa-support-agent/custom_text_input/component/frontend/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\nvar _Stream_client;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stream = void 0;\nexports._iterSSEMessages = _iterSSEMessages;\nconst tslib_1 = require(\"../internal/tslib.js\");\nconst error_1 = require(\"./error.js\");\nconst shims_1 = require(\"../internal/shims.js\");\nconst line_1 = require(\"../internal/decoders/line.js\");\nconst shims_2 = require(\"../internal/shims.js\");\nconst errors_1 = require(\"../internal/errors.js\");\nconst bytes_1 = require(\"../internal/utils/bytes.js\");\nconst log_1 = require(\"../internal/utils/log.js\");\nconst error_2 = require(\"./error.js\");\nclass Stream {\n  constructor(iterator, controller, client) {\n    this.iterator = iterator;\n    _Stream_client.set(this, void 0);\n    this.controller = controller;\n    tslib_1.__classPrivateFieldSet(this, _Stream_client, client, \"f\");\n  }\n  static fromSSEResponse(response, controller, client) {\n    let consumed = false;\n    const logger = client ? (0, log_1.loggerFor)(client) : console;\n    function iterator() {\n      return _iterator2.apply(this, arguments);\n    }\n    function _iterator2() {\n      _iterator2 = _wrapAsyncGenerator(function* () {\n        if (consumed) {\n          throw new error_1.OpenAIError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n        }\n        consumed = true;\n        let done = false;\n        try {\n          var _iteratorAbruptCompletion = false;\n          var _didIteratorError = false;\n          var _iteratorError;\n          try {\n            for (var _iterator = _asyncIterator(_iterSSEMessages(response, controller)), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n              const sse = _step.value;\n              if (done) continue;\n              if (sse.data.startsWith('[DONE]')) {\n                done = true;\n                continue;\n              }\n              if (sse.event === null || !sse.event.startsWith('thread.')) {\n                let data;\n                try {\n                  data = JSON.parse(sse.data);\n                } catch (e) {\n                  logger.error(\"Could not parse message into JSON:\", sse.data);\n                  logger.error(\"From chunk:\", sse.raw);\n                  throw e;\n                }\n                if (data && data.error) {\n                  throw new error_2.APIError(undefined, data.error, undefined, response.headers);\n                }\n                yield data;\n              } else {\n                let data;\n                try {\n                  data = JSON.parse(sse.data);\n                } catch (e) {\n                  console.error(\"Could not parse message into JSON:\", sse.data);\n                  console.error(\"From chunk:\", sse.raw);\n                  throw e;\n                }\n                // TODO: Is this where the error should be thrown?\n                if (sse.event == 'error') {\n                  throw new error_2.APIError(undefined, data.error, data.message, undefined);\n                }\n                yield {\n                  event: sse.event,\n                  data: data\n                };\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion && _iterator.return != null) {\n                yield _awaitAsyncGenerator(_iterator.return());\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n          done = true;\n        } catch (e) {\n          // If the user calls `stream.controller.abort()`, we should exit without throwing.\n          if ((0, errors_1.isAbortError)(e)) return;\n          throw e;\n        } finally {\n          // If the user `break`s, abort the ongoing request.\n          if (!done) controller.abort();\n        }\n      });\n      return _iterator2.apply(this, arguments);\n    }\n    return new Stream(iterator, controller, client);\n  }\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream(readableStream, controller, client) {\n    let consumed = false;\n    function iterLines() {\n      return _iterLines.apply(this, arguments);\n    }\n    function _iterLines() {\n      _iterLines = _wrapAsyncGenerator(function* () {\n        const lineDecoder = new line_1.LineDecoder();\n        const iter = (0, shims_2.ReadableStreamToAsyncIterable)(readableStream);\n        var _iteratorAbruptCompletion2 = false;\n        var _didIteratorError2 = false;\n        var _iteratorError2;\n        try {\n          for (var _iterator3 = _asyncIterator(iter), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator3.next())).done; _iteratorAbruptCompletion2 = false) {\n            const chunk = _step2.value;\n            for (const line of lineDecoder.decode(chunk)) {\n              yield line;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion2 && _iterator3.return != null) {\n              yield _awaitAsyncGenerator(_iterator3.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n        for (const line of lineDecoder.flush()) {\n          yield line;\n        }\n      });\n      return _iterLines.apply(this, arguments);\n    }\n    function iterator() {\n      return _iterator5.apply(this, arguments);\n    }\n    function _iterator5() {\n      _iterator5 = _wrapAsyncGenerator(function* () {\n        if (consumed) {\n          throw new error_1.OpenAIError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n        }\n        consumed = true;\n        let done = false;\n        try {\n          var _iteratorAbruptCompletion3 = false;\n          var _didIteratorError3 = false;\n          var _iteratorError3;\n          try {\n            for (var _iterator4 = _asyncIterator(iterLines()), _step3; _iteratorAbruptCompletion3 = !(_step3 = yield _awaitAsyncGenerator(_iterator4.next())).done; _iteratorAbruptCompletion3 = false) {\n              const line = _step3.value;\n              if (done) continue;\n              if (line) yield JSON.parse(line);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion3 && _iterator4.return != null) {\n                yield _awaitAsyncGenerator(_iterator4.return());\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n          done = true;\n        } catch (e) {\n          // If the user calls `stream.controller.abort()`, we should exit without throwing.\n          if ((0, errors_1.isAbortError)(e)) return;\n          throw e;\n        } finally {\n          // If the user `break`s, abort the ongoing request.\n          if (!done) controller.abort();\n        }\n      });\n      return _iterator5.apply(this, arguments);\n    }\n    return new Stream(iterator, controller, client);\n  }\n  [(_Stream_client = new WeakMap(), Symbol.asyncIterator)]() {\n    return this.iterator();\n  }\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee() {\n    const left = [];\n    const right = [];\n    const iterator = this.iterator();\n    const teeIterator = queue => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift();\n        }\n      };\n    };\n    return [new Stream(() => teeIterator(left), this.controller, tslib_1.__classPrivateFieldGet(this, _Stream_client, \"f\")), new Stream(() => teeIterator(right), this.controller, tslib_1.__classPrivateFieldGet(this, _Stream_client, \"f\"))];\n  }\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream() {\n    const self = this;\n    let iter;\n    return (0, shims_1.makeReadableStream)({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl) {\n        try {\n          const {\n            value,\n            done\n          } = await iter.next();\n          if (done) return ctrl.close();\n          const bytes = (0, bytes_1.encodeUTF8)(JSON.stringify(value) + '\\n');\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        var _iter$return, _iter;\n        await ((_iter$return = (_iter = iter).return) === null || _iter$return === void 0 ? void 0 : _iter$return.call(_iter));\n      }\n    });\n  }\n}\nexports.Stream = Stream;\nfunction _iterSSEMessages(_x, _x2) {\n  return _iterSSEMessages2.apply(this, arguments);\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nfunction _iterSSEMessages2() {\n  _iterSSEMessages2 = _wrapAsyncGenerator(function* (response, controller) {\n    if (!response.body) {\n      controller.abort();\n      if (typeof globalThis.navigator !== 'undefined' && globalThis.navigator.product === 'ReactNative') {\n        throw new error_1.OpenAIError(\"The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api\");\n      }\n      throw new error_1.OpenAIError(\"Attempted to iterate over a response with no body\");\n    }\n    const sseDecoder = new SSEDecoder();\n    const lineDecoder = new line_1.LineDecoder();\n    const iter = (0, shims_2.ReadableStreamToAsyncIterable)(response.body);\n    var _iteratorAbruptCompletion4 = false;\n    var _didIteratorError4 = false;\n    var _iteratorError4;\n    try {\n      for (var _iterator6 = _asyncIterator(iterSSEChunks(iter)), _step4; _iteratorAbruptCompletion4 = !(_step4 = yield _awaitAsyncGenerator(_iterator6.next())).done; _iteratorAbruptCompletion4 = false) {\n        const sseChunk = _step4.value;\n        for (const line of lineDecoder.decode(sseChunk)) {\n          const sse = sseDecoder.decode(line);\n          if (sse) yield sse;\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion4 && _iterator6.return != null) {\n          yield _awaitAsyncGenerator(_iterator6.return());\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n    for (const line of lineDecoder.flush()) {\n      const sse = sseDecoder.decode(line);\n      if (sse) yield sse;\n    }\n  });\n  return _iterSSEMessages2.apply(this, arguments);\n}\nfunction iterSSEChunks(_x3) {\n  return _iterSSEChunks.apply(this, arguments);\n}\nfunction _iterSSEChunks() {\n  _iterSSEChunks = _wrapAsyncGenerator(function* (iterator) {\n    let data = new Uint8Array();\n    var _iteratorAbruptCompletion5 = false;\n    var _didIteratorError5 = false;\n    var _iteratorError5;\n    try {\n      for (var _iterator7 = _asyncIterator(iterator), _step5; _iteratorAbruptCompletion5 = !(_step5 = yield _awaitAsyncGenerator(_iterator7.next())).done; _iteratorAbruptCompletion5 = false) {\n        const chunk = _step5.value;\n        if (chunk == null) {\n          continue;\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === 'string' ? (0, bytes_1.encodeUTF8)(chunk) : chunk;\n        let newData = new Uint8Array(data.length + binaryChunk.length);\n        newData.set(data);\n        newData.set(binaryChunk, data.length);\n        data = newData;\n        let patternIndex;\n        while ((patternIndex = (0, line_1.findDoubleNewlineIndex)(data)) !== -1) {\n          yield data.slice(0, patternIndex);\n          data = data.slice(patternIndex);\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion5 && _iterator7.return != null) {\n          yield _awaitAsyncGenerator(_iterator7.return());\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n    if (data.length > 0) {\n      yield data;\n    }\n  });\n  return _iterSSEChunks.apply(this, arguments);\n}\nclass SSEDecoder {\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n  decode(line) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n      const sse = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks\n      };\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n      return sse;\n    }\n    this.chunks.push(line);\n    if (line.startsWith(':')) {\n      return null;\n    }\n    let [fieldname, _, value] = partition(line, ':');\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n    return null;\n  }\n}\nfunction partition(str, delimiter) {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n  return [str, '', ''];\n}","map":{"version":3,"mappings":"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","names":["exports","Stream","constructor","iterator","controller","client","_Stream_client","tslib_1","fromSSEResponse","response","consumed","logger","console","error_1","done","_iterSSEMessages","sse","data","startsWith","event","JSON","parse","e","error","raw","error_2","undefined","headers","message","abort","fromReadableStream","readableStream","iterLines","lineDecoder","line_1","iter","chunk","line","decode","flush","Symbol","asyncIterator","tee","left","right","teeIterator","queue","next","length","result","push","shift","toReadableStream","self","start","pull","ctrl","value","close","bytes","stringify","enqueue","err","cancel","return","body","globalThis","navigator","product","sseDecoder","SSEDecoder","iterSSEChunks","sseChunk","Uint8Array","binaryChunk","ArrayBuffer","newData","set","patternIndex","slice","chunks","endsWith","substring","join","fieldname","_","partition","str","delimiter","index","indexOf"],"sourceRoot":"","sources":["../src/core/streaming.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}