{"ast":null,"code":"\"use strict\";\n\nvar _awaitAsyncGenerator = require(\"/home/morrissimons/Desktop/lysa-support-agent/custom_text_input/component/frontend/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\nvar _wrapAsyncGenerator = require(\"/home/morrissimons/Desktop/lysa-support-agent/custom_text_input/component/frontend/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChatStream = void 0;\nconst convertKeys_1 = require(\"../utils/convertKeys\");\n/**\n * Implements an async iterable that processes the readable stream of an assistant chat response.\n *\n * This class expects each chunk of data in the stream to begin with `data:` and be followed by a valid chunk of JSON.\n * If a chunk contains malformed JSON, it is skipped, and a debug message is logged.\n *\n * @template Item - The type of items yielded by the iterable.\n */\nclass ChatStream {\n  constructor(stream) {\n    this.stream = stream;\n  }\n  [Symbol.asyncIterator]() {\n    var _this = this;\n    return _wrapAsyncGenerator(function* () {\n      let buffer = '';\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(_this.stream), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n          const chunk = _step.value;\n          buffer += chunk.toString();\n          let newlineIndex;\n          while ((newlineIndex = buffer.indexOf('\\n')) !== -1) {\n            const line = buffer.slice(0, newlineIndex).trim();\n            buffer = buffer.slice(newlineIndex + 1);\n            // each chunk of json should begin with 'data:'\n            if (line && line.startsWith('data:')) {\n              const json = line.slice(5).trim();\n              try {\n                const parsedJson = JSON.parse(json);\n                const convertedJson = (0, convertKeys_1.convertKeysToCamelCase)(parsedJson);\n                yield convertedJson;\n              } catch (err) {\n                console.debug(\"Skipping malformed JSON:\".concat(line));\n                continue;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      if (buffer.trim()) {\n        try {\n          const parsedJson = JSON.parse(buffer);\n          const convertedJson = (0, convertKeys_1.convertKeysToCamelCase)(parsedJson);\n          yield convertedJson;\n        } catch (err) {\n          console.debug(\"Skipping malformed JSON:\".concat(buffer));\n        }\n      }\n    })();\n  }\n}\nexports.ChatStream = ChatStream;","map":{"version":3,"mappings":";;;;;;;;;;AACA;AAEA;;;;;;;;AAQA,MAAaA,UAAU;EAGrBC,YAAYC,MAAgB;IAC1B,IAAI,CAACA,MAAM,GAAGA,MAAM;EACtB;EAEA,CAAQC,MAAM,CAACC,aAAa,IAAC;IAAA;IAAA;MAC3B,IAAIC,MAAM,GAAG,EAAE;MAAC;MAAA;MAAA;MAAA;QAChB,oCAA0B,KAAI,CAACH,MAAM,uIAAE;UAAA,MAAtBI,KAAK;UACpBD,MAAM,IAAIC,KAAK,CAACC,QAAQ,EAAE;UAC1B,IAAIC,YAAY;UAChB,OAAO,CAACA,YAAY,GAAGH,MAAM,CAACI,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE;YACnD,MAAMC,IAAI,GAAGL,MAAM,CAACM,KAAK,CAAC,CAAC,EAAEH,YAAY,CAAC,CAACI,IAAI,EAAE;YACjDP,MAAM,GAAGA,MAAM,CAACM,KAAK,CAACH,YAAY,GAAG,CAAC,CAAC;YAEvC;YACA,IAAIE,IAAI,IAAIA,IAAI,CAACG,UAAU,CAAC,OAAO,CAAC,EAAE;cACpC,MAAMC,IAAI,GAAGJ,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,EAAE;cACjC,IAAI;gBACF,MAAMG,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;gBACnC,MAAMI,aAAa,GAAG,wCAAsB,EAACH,UAAU,CAAC;gBACxD,MAAMG,aAAqB;eAC5B,CAAC,OAAOC,GAAG,EAAE;gBACZC,OAAO,CAACC,KAAK,mCAA4BX,IAAI,EAAG;gBAChD;;;;;MAIP;QAAA;QAAA;MAAA;QAAA;UAAA;YAAA;UAAA;QAAA;UAAA;YAAA;UAAA;QAAA;MAAA;MACD,IAAIL,MAAM,CAACO,IAAI,EAAE,EAAE;QACjB,IAAI;UACF,MAAMG,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACZ,MAAM,CAAC;UACrC,MAAMa,aAAa,GAAG,wCAAsB,EAACH,UAAU,CAAC;UACxD,MAAMG,aAAqB;SAC5B,CAAC,OAAOC,GAAG,EAAE;UACZC,OAAO,CAACC,KAAK,mCAA4BhB,MAAM,EAAG;;;IAErD;EACH;;AAvCFiB","names":["ChatStream","constructor","stream","Symbol","asyncIterator","buffer","chunk","toString","newlineIndex","indexOf","line","slice","trim","startsWith","json","parsedJson","JSON","parse","convertedJson","err","console","debug","exports"],"sourceRoot":"","sources":["../../src/assistant/chatStream.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}