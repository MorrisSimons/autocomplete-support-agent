{"ast":null,"code":"\"use strict\";\n\nvar _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventStream = void 0;\nconst tslib_1 = require(\"../internal/tslib.js\");\nconst error_1 = require(\"../error.js\");\nclass EventStream {\n  constructor() {\n    _EventStream_instances.add(this);\n    this.controller = new AbortController();\n    _EventStream_connectedPromise.set(this, void 0);\n    _EventStream_resolveConnectedPromise.set(this, () => {});\n    _EventStream_rejectConnectedPromise.set(this, () => {});\n    _EventStream_endPromise.set(this, void 0);\n    _EventStream_resolveEndPromise.set(this, () => {});\n    _EventStream_rejectEndPromise.set(this, () => {});\n    _EventStream_listeners.set(this, {});\n    _EventStream_ended.set(this, false);\n    _EventStream_errored.set(this, false);\n    _EventStream_aborted.set(this, false);\n    _EventStream_catchingPromiseCreated.set(this, false);\n    tslib_1.__classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {\n      tslib_1.__classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, \"f\");\n      tslib_1.__classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    tslib_1.__classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {\n      tslib_1.__classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, \"f\");\n      tslib_1.__classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    tslib_1.__classPrivateFieldGet(this, _EventStream_connectedPromise, \"f\").catch(() => {});\n    tslib_1.__classPrivateFieldGet(this, _EventStream_endPromise, \"f\").catch(() => {});\n  }\n  _run(executor) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        this._emitFinal();\n        this._emit('end');\n      }, tslib_1.__classPrivateFieldGet(this, _EventStream_instances, \"m\", _EventStream_handleError).bind(this));\n    }, 0);\n  }\n  _connected() {\n    if (this.ended) return;\n    tslib_1.__classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, \"f\").call(this);\n    this._emit('connect');\n  }\n  get ended() {\n    return tslib_1.__classPrivateFieldGet(this, _EventStream_ended, \"f\");\n  }\n  get errored() {\n    return tslib_1.__classPrivateFieldGet(this, _EventStream_errored, \"f\");\n  }\n  get aborted() {\n    return tslib_1.__classPrivateFieldGet(this, _EventStream_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  on(event, listener) {\n    const listeners = tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  off(event, listener) {\n    const listeners = tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  once(event, listener) {\n    const listeners = tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      tslib_1.__classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    tslib_1.__classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n    await tslib_1.__classPrivateFieldGet(this, _EventStream_endPromise, \"f\");\n  }\n  _emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // make sure we don't emit any events after end\n    if (tslib_1.__classPrivateFieldGet(this, _EventStream_ended, \"f\")) {\n      return;\n    }\n    if (event === 'end') {\n      tslib_1.__classPrivateFieldSet(this, _EventStream_ended, true, \"f\");\n      tslib_1.__classPrivateFieldGet(this, _EventStream_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n    if (listeners) {\n      tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(_ref => {\n        let {\n          listener\n        } = _ref;\n        return listener(...args);\n      });\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!tslib_1.__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !(listeners === null || listeners === void 0 ? void 0 : listeners.length)) {\n        Promise.reject(error);\n      }\n      tslib_1.__classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n      tslib_1.__classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!tslib_1.__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !(listeners === null || listeners === void 0 ? void 0 : listeners.length)) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n      tslib_1.__classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n      tslib_1.__classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  _emitFinal() {}\n}\nexports.EventStream = EventStream;\n_EventStream_connectedPromise = new WeakMap(), _EventStream_resolveConnectedPromise = new WeakMap(), _EventStream_rejectConnectedPromise = new WeakMap(), _EventStream_endPromise = new WeakMap(), _EventStream_resolveEndPromise = new WeakMap(), _EventStream_rejectEndPromise = new WeakMap(), _EventStream_listeners = new WeakMap(), _EventStream_ended = new WeakMap(), _EventStream_errored = new WeakMap(), _EventStream_aborted = new WeakMap(), _EventStream_catchingPromiseCreated = new WeakMap(), _EventStream_instances = new WeakSet(), _EventStream_handleError = function _EventStream_handleError(error) {\n  tslib_1.__classPrivateFieldSet(this, _EventStream_errored, true, \"f\");\n  if (error instanceof Error && error.name === 'AbortError') {\n    error = new error_1.APIUserAbortError();\n  }\n  if (error instanceof error_1.APIUserAbortError) {\n    tslib_1.__classPrivateFieldSet(this, _EventStream_aborted, true, \"f\");\n    return this._emit('abort', error);\n  }\n  if (error instanceof error_1.OpenAIError) {\n    return this._emit('error', error);\n  }\n  if (error instanceof Error) {\n    const openAIError = new error_1.OpenAIError(error.message);\n    // @ts-ignore\n    openAIError.cause = error;\n    return this._emit('error', openAIError);\n  }\n  return this._emit('error', new error_1.OpenAIError(String(error)));\n};","map":{"version":3,"mappings":"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","names":["EventStream","constructor","AbortController","_EventStream_connectedPromise","_EventStream_resolveConnectedPromise","_EventStream_rejectConnectedPromise","_EventStream_endPromise","_EventStream_resolveEndPromise","_EventStream_rejectEndPromise","_EventStream_listeners","_EventStream_ended","_EventStream_errored","_EventStream_aborted","_EventStream_catchingPromiseCreated","tslib_1","Promise","resolve","reject","catch","_run","executor","setTimeout","then","_emitFinal","_emit","bind","_connected","ended","errored","aborted","abort","controller","on","event","listener","listeners","push","off","index","findIndex","l","splice","once","emitted","done","args","filter","forEach","error","length","exports","Error","name","error_1","openAIError","message","cause","String"],"sourceRoot":"","sources":["../src/lib/EventStream.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}