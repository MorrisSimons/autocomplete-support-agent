{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/morrissimons/Desktop/lysa-support-agent/custom_text_input/component/frontend/node_modules/@babel/runtime/helpers/objectSpread2\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isChatCompletionFunctionTool = isChatCompletionFunctionTool;\nexports.makeParseableResponseFormat = makeParseableResponseFormat;\nexports.makeParseableTextFormat = makeParseableTextFormat;\nexports.isAutoParsableResponseFormat = isAutoParsableResponseFormat;\nexports.makeParseableTool = makeParseableTool;\nexports.isAutoParsableTool = isAutoParsableTool;\nexports.maybeParseChatCompletion = maybeParseChatCompletion;\nexports.parseChatCompletion = parseChatCompletion;\nexports.shouldParseToolCall = shouldParseToolCall;\nexports.hasAutoParseableInput = hasAutoParseableInput;\nexports.assertToolCallsAreChatCompletionFunctionToolCalls = assertToolCallsAreChatCompletionFunctionToolCalls;\nexports.validateInputTools = validateInputTools;\nconst error_1 = require(\"../error.js\");\nfunction isChatCompletionFunctionTool(tool) {\n  return tool !== undefined && 'function' in tool && tool.function !== undefined;\n}\nfunction makeParseableResponseFormat(response_format, parser) {\n  const obj = _objectSpread({}, response_format);\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nfunction makeParseableTextFormat(response_format, parser) {\n  const obj = _objectSpread({}, response_format);\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nfunction isAutoParsableResponseFormat(response_format) {\n  return (response_format === null || response_format === void 0 ? void 0 : response_format['$brand']) === 'auto-parseable-response-format';\n}\nfunction makeParseableTool(tool, _ref) {\n  let {\n    parser,\n    callback\n  } = _ref;\n  const obj = _objectSpread({}, tool);\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nfunction isAutoParsableTool(tool) {\n  return (tool === null || tool === void 0 ? void 0 : tool['$brand']) === 'auto-parseable-tool';\n}\nfunction maybeParseChatCompletion(completion, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return _objectSpread(_objectSpread({}, completion), {}, {\n      choices: completion.choices.map(choice => {\n        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);\n        return _objectSpread(_objectSpread({}, choice), {}, {\n          message: _objectSpread(_objectSpread({}, choice.message), {}, {\n            parsed: null\n          }, choice.message.tool_calls ? {\n            tool_calls: choice.message.tool_calls\n          } : undefined)\n        });\n      })\n    });\n  }\n  return parseChatCompletion(completion, params);\n}\nfunction parseChatCompletion(completion, params) {\n  const choices = completion.choices.map(choice => {\n    var _choice$message$tool_, _choice$message$tool_2;\n    if (choice.finish_reason === 'length') {\n      throw new error_1.LengthFinishReasonError();\n    }\n    if (choice.finish_reason === 'content_filter') {\n      throw new error_1.ContentFilterFinishReasonError();\n    }\n    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);\n    return _objectSpread(_objectSpread({}, choice), {}, {\n      message: _objectSpread(_objectSpread(_objectSpread({}, choice.message), choice.message.tool_calls ? {\n        tool_calls: (_choice$message$tool_ = (_choice$message$tool_2 = choice.message.tool_calls) === null || _choice$message$tool_2 === void 0 ? void 0 : _choice$message$tool_2.map(toolCall => parseToolCall(params, toolCall))) !== null && _choice$message$tool_ !== void 0 ? _choice$message$tool_ : undefined\n      } : undefined), {}, {\n        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null\n      })\n    });\n  });\n  return _objectSpread(_objectSpread({}, completion), {}, {\n    choices\n  });\n}\nfunction parseResponseFormat(params, content) {\n  var _params$response_form, _params$response_form2;\n  if (((_params$response_form = params.response_format) === null || _params$response_form === void 0 ? void 0 : _params$response_form.type) !== 'json_schema') {\n    return null;\n  }\n  if (((_params$response_form2 = params.response_format) === null || _params$response_form2 === void 0 ? void 0 : _params$response_form2.type) === 'json_schema') {\n    if ('$parseRaw' in params.response_format) {\n      const response_format = params.response_format;\n      return response_format.$parseRaw(content);\n    }\n    return JSON.parse(content);\n  }\n  return null;\n}\nfunction parseToolCall(params, toolCall) {\n  var _params$tools;\n  const inputTool = (_params$tools = params.tools) === null || _params$tools === void 0 ? void 0 : _params$tools.find(inputTool => {\n    var _inputTool$function;\n    return isChatCompletionFunctionTool(inputTool) && ((_inputTool$function = inputTool.function) === null || _inputTool$function === void 0 ? void 0 : _inputTool$function.name) === toolCall.function.name;\n  }); // TS doesn't narrow based on isChatCompletionTool\n  return _objectSpread(_objectSpread({}, toolCall), {}, {\n    function: _objectSpread(_objectSpread({}, toolCall.function), {}, {\n      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool === null || inputTool === void 0 ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null\n    })\n  });\n}\nfunction shouldParseToolCall(params, toolCall) {\n  var _params$tools2;\n  if (!params || !('tools' in params) || !params.tools) {\n    return false;\n  }\n  const inputTool = (_params$tools2 = params.tools) === null || _params$tools2 === void 0 ? void 0 : _params$tools2.find(inputTool => {\n    var _inputTool$function2;\n    return isChatCompletionFunctionTool(inputTool) && ((_inputTool$function2 = inputTool.function) === null || _inputTool$function2 === void 0 ? void 0 : _inputTool$function2.name) === toolCall.function.name;\n  });\n  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || (inputTool === null || inputTool === void 0 ? void 0 : inputTool.function.strict) || false);\n}\nfunction hasAutoParseableInput(params) {\n  var _params$tools$some, _params$tools3;\n  if (isAutoParsableResponseFormat(params.response_format)) {\n    return true;\n  }\n  return (_params$tools$some = (_params$tools3 = params.tools) === null || _params$tools3 === void 0 ? void 0 : _params$tools3.some(t => isAutoParsableTool(t) || t.type === 'function' && t.function.strict === true)) !== null && _params$tools$some !== void 0 ? _params$tools$some : false;\n}\nfunction assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {\n  for (const toolCall of toolCalls || []) {\n    if (toolCall.type !== 'function') {\n      throw new error_1.OpenAIError(\"Currently only `function` tool calls are supported; Received `\".concat(toolCall.type, \"`\"));\n    }\n  }\n}\nfunction validateInputTools(tools) {\n  for (const tool of tools !== null && tools !== void 0 ? tools : []) {\n    if (tool.type !== 'function') {\n      throw new error_1.OpenAIError(\"Currently only `function` tool types support auto-parsing; Received `\".concat(tool.type, \"`\"));\n    }\n    if (tool.function.strict !== true) {\n      throw new error_1.OpenAIError(\"The `\".concat(tool.function.name, \"` tool is not marked with `strict: true`. Only strict function tools can be auto-parsed\"));\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["exports","isChatCompletionFunctionTool","tool","undefined","function","makeParseableResponseFormat","response_format","parser","obj","Object","defineProperties","$brand","value","enumerable","$parseRaw","makeParseableTextFormat","isAutoParsableResponseFormat","makeParseableTool","callback","$callback","isAutoParsableTool","maybeParseChatCompletion","completion","params","hasAutoParseableInput","choices","map","choice","assertToolCallsAreChatCompletionFunctionToolCalls","message","tool_calls","parsed","parseChatCompletion","finish_reason","error_1","toolCall","parseToolCall","content","refusal","parseResponseFormat","type","JSON","parse","inputTool","tools","find","name","parsed_arguments","arguments","strict","shouldParseToolCall","some","t","toolCalls","validateInputTools"],"sourceRoot":"","sources":["../src/lib/parser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}