{"ast":null,"code":"\"use strict\";\n\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _objectSpread = require(\"/home/morrissimons/Desktop/lysa-support-agent/custom_text_input/component/frontend/node_modules/@babel/runtime/helpers/objectSpread2\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Embeddings = void 0;\nconst resource_1 = require(\"../core/resource.js\");\nconst utils_1 = require(\"../internal/utils.js\");\nclass Embeddings extends resource_1.APIResource {\n  /**\n   * Creates an embedding vector representing the input text.\n   *\n   * @example\n   * ```ts\n   * const createEmbeddingResponse =\n   *   await client.embeddings.create({\n   *     input: 'The quick brown fox jumped over the lazy dog',\n   *     model: 'text-embedding-3-small',\n   *   });\n   * ```\n   */\n  create(body, options) {\n    const hasUserProvidedEncodingFormat = !!body.encoding_format;\n    // No encoding_format specified, defaulting to base64 for performance reasons\n    // See https://github.com/openai/openai-node/pull/1312\n    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : 'base64';\n    if (hasUserProvidedEncodingFormat) {\n      (0, utils_1.loggerFor)(this._client).debug('embeddings/user defined encoding_format:', body.encoding_format);\n    }\n    const response = this._client.post('/embeddings', _objectSpread({\n      body: _objectSpread(_objectSpread({}, body), {}, {\n        encoding_format: encoding_format\n      })\n    }, options));\n    // if the user specified an encoding_format, return the response as-is\n    if (hasUserProvidedEncodingFormat) {\n      return response;\n    }\n    // in this stage, we are sure the user did not specify an encoding_format\n    // and we defaulted to base64 for performance reasons\n    // we are sure then that the response is base64 encoded, let's decode it\n    // the returned result will be a float32 array since this is OpenAI API's default encoding\n    (0, utils_1.loggerFor)(this._client).debug('embeddings/decoding base64 embeddings from base64');\n    return response._thenUnwrap(response => {\n      if (response && response.data) {\n        response.data.forEach(embeddingBase64Obj => {\n          const embeddingBase64Str = embeddingBase64Obj.embedding;\n          embeddingBase64Obj.embedding = (0, utils_1.toFloat32Array)(embeddingBase64Str);\n        });\n      }\n      return response;\n    });\n  }\n}\nexports.Embeddings = Embeddings;","map":{"version":3,"mappings":";;AAAA;AAAA;;;;;AAEA;AAGA;AAEA,MAAaA,UAAW,SAAQC,sBAAW;EACzC;;;;;;;;;;;;EAYAC,MAAM,CAACC,IAA2B,EAAEC,OAAwB;IAC1D,MAAMC,6BAA6B,GAAG,CAAC,CAACF,IAAI,CAACG,eAAe;IAC5D;IACA;IACA,IAAIA,eAAe,GACjBD,6BAA6B,GAAGF,IAAI,CAACG,eAAe,GAAG,QAAQ;IAEjE,IAAID,6BAA6B,EAAE;MACjC,qBAAS,EAAC,IAAI,CAACE,OAAO,CAAC,CAACC,KAAK,CAAC,0CAA0C,EAAEL,IAAI,CAACG,eAAe,CAAC;IACjG;IAEA,MAAMG,QAAQ,GAAwC,IAAI,CAACF,OAAO,CAACG,IAAI,CAAC,aAAa;MACnFP,IAAI,kCACCA,IAAI;QACPG,eAAe,EAAEA;MAA2D;IAC7E,GACEF,OAAO,EACV;IAEF;IACA,IAAIC,6BAA6B,EAAE;MACjC,OAAOI,QAAQ;IACjB;IAEA;IACA;IACA;IACA;IACA,qBAAS,EAAC,IAAI,CAACF,OAAO,CAAC,CAACC,KAAK,CAAC,mDAAmD,CAAC;IAElF,OAAQC,QAAgD,CAACE,WAAW,CAAEF,QAAQ,IAAI;MAChF,IAAIA,QAAQ,IAAIA,QAAQ,CAACG,IAAI,EAAE;QAC7BH,QAAQ,CAACG,IAAI,CAACC,OAAO,CAAEC,kBAAkB,IAAI;UAC3C,MAAMC,kBAAkB,GAAGD,kBAAkB,CAACE,SAA8B;UAC5EF,kBAAkB,CAACE,SAAS,GAAG,0BAAc,EAACD,kBAAkB,CAAC;QACnE,CAAC,CAAC;MACJ;MAEA,OAAON,QAAQ;IACjB,CAAC,CAAC;EACJ;;AArDFQ","names":["Embeddings","resource_1","create","body","options","hasUserProvidedEncodingFormat","encoding_format","_client","debug","response","post","_thenUnwrap","data","forEach","embeddingBase64Obj","embeddingBase64Str","embedding","exports"],"sourceRoot":"","sources":["../src/resources/embeddings.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}